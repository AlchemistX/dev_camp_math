\documentclass[twoside]{article}

\usepackage{lipsum} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them 

\usepackage{braket}
\usepackage{array}
\usepackage{calc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw]{xcolor}
\usepackage{adjustbox}
\usepackage{kotex}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}



\hypersetup{%
    pdfborder = {0 0 0}
}



\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{ Fastcampus Math Camp  } % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{ Introduction to Python }} % Article title

\author{
\large
\textsc{Seungwoo Schin}\\[2mm]
\normalsize Coding the Mathematics Course, Fastcampus \\ % Your institution
\vspace{-5mm}
}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert title

\thispagestyle{fancy} % All pages have headers and footers

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\lstdefinestyle{python}{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}
    
\lstdefinestyle{stdout}{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}
    
    
\lstdefinestyle{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

    



\section{파이썬 소개} 


\lstinputlisting[style=python, 
                caption={Hello World! (hello.py)}]{"../../../src/examples/hello.py"}


본 단락에서는 파이썬 언어에 대해서 간단히 짚고 넘어갑니다. 

\subsection{파이썬 데이터 타입} 

\subsubsection{Built-in Data Types} 
파이썬은 기본적으로 다음의 빌트인 데이터 타입을 지원\footnote{\href{https://en.wikibooks.org/wiki/Python\_Programming/Data\_Types}{참조 링크 1(위키북스)}, \href{https://docs.python.org/3/library/stdtypes.html}{참조 링크 2(공식 문서)}}\footnote{여기 리스트된 데이터형이 전부는 아니지만, 중요한 데이터형들이니 잘 알아두시길 권장합니다.}합니다. 

\begin{compactitem} 
\item Boolean Type : 참/거짓 값을 나타내는 타입입니다. 
\item Numeric Types : 일반적으로 쓰이는 숫자를 나타내는 타입입니다. 
\item Sequential Types : 배열 형태의 타입입니다. 
\item Mapping Types : key-value 순서쌍 형태의 타입입니다. \footnote{프로그래밍 지식이 있으신 분은 파이썬에서의 dict가 해쉬라고 생각하시면 좋습니다.}
\end{compactitem}

아래에서는 각 타입의 종류와 다양한 연산법에 대해서 알아볼 것입니다. 


\paragraph{Boolean Type} 참(True), 거짓(False)값을 나타냅니다. Boolean 값들은 and, or, not 연산이 가능합니다. 연산의 결과는 아래와 같습니다. 

\lstinputlisting[style=python, 
                caption={Boolean Example  (example\_bool1.py)}]{"../../../src/examples/example_bool1.py"}


\paragraph{Numeric Types} int, float, complex가 있습니다. 각각 정수, 실수\footnote{차후에 다루겠지만, 정확하게 실수를 나타내는 것은 불가능합니다. 더 정확하게는, 모든 실수를 정확하게 나타내는 것은 불가능합니다. 여기서의 float은 c언어에서의 double과 같다고 보는 것이 정확합니다.}, 그리고 복소수를 나타냅니다. 

\lstinputlisting[style=python, 
                caption={Numeric Types  (example\_numeric1.py)}]{"../../../src/examples/example_numeric1.py"}

파이썬은 일반적인 사칙연산을 지원합니다. 아래에서 어떤 식으로 사칙연산이 사용되는지 볼 수 있습니다. 

\lstinputlisting[style=python, 
                caption={Operations for Numeric Types  (example\_numeric2.py)}]{"../../../src/examples/example_numeric2.py"}


\paragraph{Sequential Types} 파이썬에서는 list, tuple, range, string 등의 배열 형태의 데이터형을 지원합니다. 여기서는 문자열 데이터형 string에 대해서 따로 다루지는 않으며, 더 자세한 정보는 \href{https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range}{공식 Documentation}을 참고하시면 됩니다. 

\lstinputlisting[style=python, 
                caption={Sequential Types  (example\_sequence1.py)}]{"../../../src/examples/example_sequence1.py"}


Sequence 데이터형들은 다음의 연산들을 지원합니다. 
\begin{compactitem} 
\item a in d : 배열(d) 안에 특정 원소(a)가 있는지를 검사합니다. 
\item + : 배열 두 개를 이어서 새로운 배열을 만듭니다. 같은 데이터형이여야 합니다. 
\item d[i] : d의 i번째 원소를 반환합니다. 
\item d[i:j:k] : d의 i번째 원소부터 j번째 원소까지, k번째 원소마다 선택하여 리스트를 만들어 반환합니다. 
\item d.index(elem) : d에서 elem 이 처음으로 나오는 위치를 반환합니다. 
\end{compactitem}
\lstinputlisting[style=python, 
                caption={Operations for Sequential Types  (example\_sequence2.py)}]{"../../../src/examples/example_sequence2.py"}


\paragraph{Mapping Types} key-value 쌍을 저장하는 데이터형으로, 파이썬에서는 dict가 있습니다. 

\lstinputlisting[style=python, 
                linerange  = {1-6, 27},
                caption={Mapping Types  (example\_dict1.py, line 7-26 omitted)}]{"../../../src/examples/example_dict1.py"}

dict는 다음의 연산을 지원합니다. 
\begin{compactitem} 
\item d[key] : dict에서 key에 해당되는 value를 반환합니다. 
\item d[key] = val : dict에서 key에 해당되는 value를 val로 업데이트합니다. 
\item d.keys() : dict의 key들을 반환합니다. 
\end{compactitem}

\lstinputlisting[style=python, 
                caption={Operations for Mapping Types  (example\_dict2.py)}]{"../../../src/examples/example_dict2.py"}


\subsection{파이썬 문법 : loops, conditionals} 

\paragraph{if-elif-else} 다른 모든 언어와 비슷하게, 파이썬에서도 if-else 문을 지원합니다. 아래와 같은 문법으로 사용됩니다. 

\begin{lstlisting}[style=python] 
if cond1:
    # when cond1 is True 
elif cond2:
    # when cond1 is False and cond2 is True
else:
    # when cond1 is False and cond2 is False
\end{lstlisting}

\paragraph{switch} 파이썬에서는 switch문을 지원하지 않습니다. 하지만, 아래와 같이 switch문을 대체하여 사용할 수는 있습니다. 

\lstinputlisting[style=python, 
                caption={Switch using dict (example\_switch1.py)}]{"../../../src/examples/example_switch1.py"}



\paragraph{for loop} 파이썬에서의 for loop는 임의의 Sequential Type 변수에 대해서, 그 변수 안의 원소를 한번씩 돌게 됩니다. 예를 들어서 아래 코드를 살펴봅시다. 

\lstinputlisting[style=python, 
                caption={For Loop Example (example\_for1.py)}]{"../../../src/examples/example_for1.py"}


\paragraph{while loop} 파이썬에서의 while문은 다른 언어에서의 while문과 크게 다르지 않습니다. 아래의 소스 코드를 살펴보면 알 수 있을 것입니다. 


\lstinputlisting[style=python, 
                caption={While Loop Example (example\_while1.py)}]{"../../../src/examples/example_while1.py"}
                
                
\subsection{파이썬 문법 : 함수, 클래스}

\subsubsection{함수}

파이썬에서 함수는 다음과 같이 정의합니다. 


\lstinputlisting[style=python, 
                caption={Function Syntax (example\_function1.py)}]{"../../../src/examples/example_function1.py"}
                
위 소스코드에서 각 항목은 아래와 같은 의미를 가집니다. 

\begin{compactitem} 
\item def : 함수 정의 키워드입니다. 
\item function : 함수 이름을 나타냅니다. 
\item args : 함수 인자입니다. 아래와 같은 옵션이 있습니다. 
\begin{compactitem} 
\item arg 
\item arg\_default : 함수 인자의 기본값을 정해줄 때, =을 이용하여 기본값을 지정해줄 수 있습니다. 
\item *arg\_list : 정해지지 않은 수의 인자를 받고자 할 때, *을 하나 붙여서 들어온 인자를 배열로 받을 수 있습니다. 
\item **arg\_dict : 정해지지 않은 수의 이름이 명시된 인자를 받고자 할 때, *를 두개 붙여서 들어온 인자들을 dict 형태로 받을 수 있습니다. 
\end{compactitem} 
\item return None : 함수의 결과값으로 return 뒤의 구문을 반환합니다. 
\end{compactitem}


아래의 코드\footnote{\href{https://stackoverflow.com/a/21338152}{stackoverflow 질문 : Understanding kwargs in Python} 참조}를 보면 조금 더 명백해집니다. 

\lstinputlisting[style=python, 
                caption={Function Argument Options (example\_function2.py)}]{"../../../src/examples/example_function2.py"}
                
위 프로그램의 실행 결과는 다음과 같습니다. 

\begin{lstlisting}[style=stdout, caption = {Output for Function Argmument Options}]
Calling f(1, 2, 3, 4, b = 5, c = 6)
Received by f(a, *args, **kwargs) 
=> f(a=1, args=(2, 3, 4), kwargs={'c': 6, 'b': 5}
Calling g(10, 11, 12, *args, d = 13, e = 14, **kwargs)
Received by g(f, g = 0, *args, **kwargs)
=> g(f=10, g=11, args=(12, 2, 3, 4), kwargs={'c': 6, 'b': 5, 'e': 14, 'd': 13})
\end{lstlisting}

\paragraph{람다 함수}

람다 함수란 익명함수를 뜻합니다. 이는 람다함수가 변수명을 가질 수 없음을 의미하는 것이 \textbf{아닙니다.} 예컨대, 아래의 코드에서의 func1, func2는 둘 다 같은 함수(주어진 수에 2를 더하는)이며, func1은 람다식으로 작성되었지만 엄연히 func1이라는 이름을 가지고 있습니다. 

\lstinputlisting[style=python,  
                caption={Lambda Function Example (example\_lambda1.py)}]{"../../../src/examples/example_lambda1.py"}

람다식의 문법은 위 소스 코드에서 볼 수 있듯이 다음과 같이 이루어집니다. 

\begin{compactitem} 
\item lambda : 람다함수 키워드. 람다함수 뒤의 구문 중 콜론 전에 있는 구문은 함수의 인자를, 뒤는 반환하는 값을 나타낸다. 
\item x,y,z(func3)/*args(func4) : 람다함수의 인자. 쉼표로 구분되며, 상기된 *args등도 똑같이 사용 가능함을 func4에서 확인할 수 있다. 
\item x+y+z(func3)/sum(args)(func4) : 람다함수의 반환값. 
\end{compactitem}

익명함수가 가지는 이점 중 하나는, 우리가 정수나 문자열을 다루듯이 함수 또한 하나의 변수로 다루고 싶을 때 편리하다는 점입니다. 본 단락에서는 일반화된 정렬 문제에서 어떤 식으로 람다식이 사용가능한지 보여드리고자 합니다. 

어떤 배열을 정렬하는 문제를 생각해 봅시다. 이 때, 어떤 배열의 원소들이 정수라면 정렬 결과에는 이의가 없을 것입니다. 예컨대, 아래의 코드의 마지막 라인에서 AssertionError가 나지 않는다면 충분할 것입니다. \footnote{물론 실전에서는 더 많은 테스트를 하시는 것을 권장드립니다.}


\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort1.py)}]{"../../../src/examples/example_lambda_sort1.py"}


하지만 주어진 리스트가 비교하기 어려운 것들로 되어있는 경우 - 예를 들어서, 숫자 3개짜리 튜플로 되어있는 경우 - 에는 어떤 식으로 배열할 수 있을까요? 이를 위해서는 우선 배열의 원소를 서로 비교하기 위한 기준이 필요할 것입니다. 위 코드의 경우 원소간의 비교 기준은 대소관계이며, 8번째 라인(head>=elem)에 이것이 반영되었다고 볼 수 있습니다. 여기서는 이 기준을 세 숫자의 합으로 생각해 봅시다. 그렇다면, 새로운 기준(세 숫자의 합)을 아래와 같이 반영할 수 있을 것입니다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort2.py)}]{"../../../src/examples/example_lambda_sort2.py"}


이제 여기서 조금 더 나아가서, 다음과 같은 소스를 생각해 봅시다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort3.py)}]{"../../../src/examples/example_lambda_sort3.py"}

여기서, 위 소스를 조금 더 간소화해서 애초에 compare 함수를 def를 쓰지 않고 람다식을 이용하여 저렇게 쓸 수 있습니다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort4.py)}]{"../../../src/examples/example_lambda_sort4.py"}

\subsubsection{클래스}

본 단락에서는 파이썬에서 클래스를 어떻게 정의하는지를 살펴보고자 합니다. 

\paragraph{클래스란} 

클래스는 흔히 과자틀과 그 과자틀로 찍어낸 과자로 비유됩니다.  클래스는 객체를 만들기 위한 코드 템플릿\footnote{https://www.hackerearth.com/practice/python/object-oriented-programming/classes-and-objects-i/tutorial/}을 말합니다. 인스턴스는 이 템플릿을 이용하여 만들어진 코드 덩어리로 생각할 수 있습니다. 예\footnote{본 예시는 \ href{https://wikidocs.net/28}{점프 투 파이썬}에서 참고하였습니다.}를 들어서, 더하기만 가능한 간단한 계산기 코드를 만든다고 가정합시다. 다음과 같이 전역변수를 사용하면 어렵지 않게 구현할 수 있을 것입니다. 

\lstinputlisting[style=python,  
                caption={더하기만 가능한 계산기  (example\_cal1.py)}]{"../../../src/examples/example_cal1.py"}

이 때, 각자 다른 계산기를 2개를 만들어서 사용하고자 하면, 다음과 같이 2개의 계산기를 만들어야 할 것입니다.

\lstinputlisting[style=python,  
                caption={더하기만 가능한 계산기 2개 (example\_cal2.py)}]{"../../../src/examples/example_cal2.py"}

이렇게 코드를 작성할 경우, 완벽하게 똑같은 코드를 두 번 작성해야 함을 알 수 있습니다. 따라서 이러한 중복을 피하기 위해서, 파이썬에서는 - 그리고 객체지향적 언어에서는 - 클래스를 제공합니다. 클래스는 다음과 같이 계산기 코드를 템플릿화하여, 재사용이 용이하게 만듭니다. 


\lstinputlisting[style=python,  
                caption={더하기 계산기 클래스  (example\_cal3.py)}]{"../../../src/examples/example_cal3.py"}

이 때, cal1, cal2는 클래스 Calculator의 인스턴스입니다. 

클래스를 사용하는 이유는 개발의 속도와 유지보수의 편의성, 그리고 코드 디자인의 간결성 때문입니다. 잘 구성된 클래스의 경우, 구현하고자 하는 대상과 구현하는 프로그램 소스 코드간 대응이 직관적입니다. 예컨대 회계사용 프로그램을 작성할 경우, 고객/법인/재무재표 등의 클래스를 사용하게 될 것입니다. 이런 경우, 단순 코드 블럭으로 되어있는 것보다 더 직관적으로 프로그램 전체의 구조를 이해할 수 있으며, 이는 개발 속도와 정확도에 긍정적인 영향을 끼칠 것입니다. 프로그램의 유지보수 측면에서도 이와 비슷한 이유로 추후 유지보수가 간결해집니다. 

이제 조금 더 자세하게 클래스(특히, 파이썬에서의 클래스에 대해서) 알아보겠습니다. 

\paragraph{파이썬에서의 클래스} 

위 단락에서 클래스가 무엇인지, 그리고 왜 필요한지에 대해서 간단하게 살펴보았습니다. 본 단락에서는 클래스를 구성하는 요소를 살펴보고, 이를 정의하는 파이썬 문법에 대해서 알아보고자 합니다. 이해를 돕기 위해서 여기서는 문자열을 다루는 간단한 클래스를 만들어보고자 합니다. 먼저, 

클래스는 속성(attribute)와 메소드(method)로 구성됩니다. 속성은 클래스 속성과 인스턴스 속성으로 분류되며, 메소드는 인스턴스 메소드, 클래스 메소드, 스태틱 메소드로 분류됩니다. \footnote{파이썬의 경우, private method를 지원하기는 하나 완벽하게 private하지는 않습니다. \_\_로 시작하는 속성이나 메소드는 private로 분류되지만, 이것이 완벽하게 클래스 밖에서 은닉되어 있지는 않습니다. 예컨대, 클래스 이름이 Mycls이고 속성이 \_\_attr1일 경우, Mycls\_\_attr1 로 접근할 수 있습니다. 더 자세한 내용은 \href{http://www.diveintopython.net/object\_oriented\_framework/private\_functions.html}{참고 링크}를 참고하세요. } 

각각의 예시에 대해서 아래 코드에서 살펴보겠습니다. 먼저, 가장 기본적인 부분만을 작성한 코드를 살펴보겠습니다. 

\lstinputlisting[style=python,  
		linerange = {1-8},
                caption={Making a MyString Class  (example\_class1.py)}]{"../../../src/examples/example_class1.py"}

위 코드에서 파이썬 클래스의 각 요소들을 설명하면 다음과 같습니다. 
\begin{compactitem} 
\item class : 클래스를 정의하는 키워드입니다. 이 키워드 뒤의 단어가 클래스의 이름이 됩니다. 여기서는 MyString입니다. 
\item maker = 'Schin' : 클래스의 \textbf{속성}을 지정합니다. 여기서는 class\_name, maker, datum의 3개의 속성이 있습니다. 편의상 datum을 우리가 다루고자 하는 문자열로 생각하겠습니다. 
\item a = MyString : a라는 변수의 값으로 MyString이라는 \textbf{클래스}를 지정합니다. 
\item b = MyString() : b라는 변수의 값으로 MyString이라는 \textbf{인스턴스}를 지정합니다. 
\end{compactitem}

여기서 클래스(a)와 인스턴스(b)의 차이를 살펴보기 위해서 다음 코드를 실행해 보겠습니다. 

\lstinputlisting[style=python,  
		linerange = {10-17},
                caption={Making a MyString Class  (example\_class1.py)}]{"../../../src/examples/example_class1.py"}

여기서 볼 수 있듯이, 클래스 자체의 변화는 인스턴스에 영향을 주지만 그 역은 성립하지 않습니다. 이는 모든 인스턴스는 클래스의 틀을 따르기 때문입니다. 위에서의 쿠키틀의 예시를 들면, 쿠키 하나를 바꾼다고 쿠키틀이 바뀌지는 않는 것과 같습니다. 반대로, 쿠키틀을 바꾸면 모든 쿠키는 영향을 받게 됩니다. 


본격적으로 문자열을 다루기 위해서 b에 우리가 다루고자 하는 문자열을 저장하고자 합니다. 이는 다음과 같은 방식으로 할 수 있습니다. 

\lstinputlisting[style=python,  
		linerange = {19-20},
                caption={MyClass Attribute   (example\_class1.py)}]{"../../../src/examples/example_class1.py"}

이제 이 후에는 어떻게 해야 할까요? 문자열을 저장하는 것만으로는 충분하지 않습니다. 이제 조금 더 복잡한 클래스 문법을 살펴보겠습니다. 

\lstinputlisting[style=python,  
		linerange = {1-33},
                caption={Making a MyString Class  (example\_class2.py)}]{"../../../src/examples/example_class2.py"}

\begin{compactitem}
\item 속성(Attribute) : 클래스나 인스턴스가 가지고 있는 정보를 말합니다. 예를 들어서, 문자열의 경우라면 문자열의 내용이나 저자 등이 있을 것입니다. 
\begin{compactitem} 
\item 클래스 속성  : 클래스 자체가 가지고 있는 속성을 말합니다. 예를 들어서, 문자열의 경우라면 클래스 이름 MyString 등이 있습니다. 
\item 인스턴스 속성 : 인스턴스 각각이 가지고 있는 속성을 말합니다. 예를 들어서, 문자열의 경우라면 문자열의 내용 등이 있습니다. 
\end{compactitem}
\item 메소드(method) : 클래스나 인스턴스의 상태를 변화시키거나, 새로운 클래스를 만드는 등의 작업을 하는 함수입니다. 
\begin{compactitem} 
\item 인스턴스 메소드 : 인스턴스에 대해서 작동하는 함수입니다. 인스턴스를 변형시키거나 인스턴스를 이용하여 어떠한 작업을 수행합니다. 
\item 클래스 메소드 : 클래스에 대해서 작동하는 함수입니다. 클래스 자체를 변형시킬 수 있습니다. 
\item 스태틱 메소드 : 클래스나 인스턴스와 상관없는 함수입니다. 보통 클래스 내에서만 쓰이지만, 딱히 인스턴스나 클래스의 정보를 필요로 하지 않는 경우에 쓰입니다. 

\end{compactitem}
\end{compactitem}



위 소스 코드를 통해서 우리는 다음과 같은 일들을 할 수 있습니다. 

\lstinputlisting[style=python,  
		linerange = {42-55},
                caption={MyClass Attribute   (example\_class2.py)}]{"../../../src/examples/example_class2.py"}



%\paragraph{Magic Methods} Magic Method는 대표적인 syntactic sugar로써, 일반적으로 \_\_\textit{method\_name}\_\_형태로 메소드를 지칭합니다.

%\lstinputlisting[style=python,  
%                caption={Inspecting Function Calls  (example\_class2.py)}]{"../../../src/examples/example_class2.py"}

%\paragraph{클래스 상속} 클래스 상속\footnote{\href{https://www.python-course.eu/python3\_inheritance.php}{링크} 참조}
%
%\lstinputlisting[style=python,  
%                caption={Inspecting Function Calls  (example\_class3.py)}]{"../../../src/examples/example_class3.py"}

\subsection{파이썬 인터프리터의 이해}

본 단락에서는 주어진 소스 코드를 파이썬이 계산하는 법을 알아볼 것\footnote{\href{https://docs.python.org/3/reference/executionmodel.html}{파이썬 공식 Documentation} 참조}입니다. 본격적인 설명에 앞서, 변수의 종류에 대해서 설명하겠습니다. 일반적으로 변수에는 다음의 세 종류가 있습니다. 

\begin{compactitem} 
\item Bound variable : 어떤 값이나 다른 변수에 의해서 값이 결정되는지 정해진 변수
\item Binding variable : Bound variable의 값을 결정하는 변수 
\item Free variable : Bound되지 않은 변수 
\end{compactitem}

이 때, 파이썬 인터프리터\footnote{사실 많은 인터프리터가 대부분 이렇게 동작합니다.}는 \textbf{bound variable을 binding variable로 대체(substitute) 하여} 계산합니다. 만약 계산해야 하는 모든 변수들의 값이 결국 어떤 값(숫자, 문자열 등등)으로 환원되면 그 값을 계산하여 반환하고, 그렇지 않다면 에러를 반환합니다. 따라서 파이썬 인터프리터의 동작을 이해하는 것은 곧 어떤 식으로 변수들이 서로를 bind/bound 하는지를 이해하고, 이를 기반으로 \textbf{기계적으로} 변수를 적절한 값으로 대체하여 계산을 수행함을 의미합니다. 

Binding이 일어나는 경우는 아래와 같습니다. 

\paragraph{import문의 사용} import문을 사용할 경우, import된 모듈에서의 모든 namespace가 bind됩니다. 

\paragraph{for loop} for loop에서 헤더는 루프 코드블럭 안에서 for loop 헤더에서 선언된 변수를 bind 합니다. 

\paragraph{함수, 클래스의 정의} 함수나 클래스의 정의는 함수나 클래스 이름을 bind하게 됩니다. 예를 들어서 아래 소스코드를 보면, compare이라는 변수는 1번 라인에 의해서 2번 라인에 binding되어, 14번 라인을 거쳐 11번 라인에서 쓰이게 됩니다. 


\lstinputlisting[style=python,  
                caption={Binding in Function definition  (example\_lambda\_sort3.py)}]{"../../../src/examples/example_lambda_sort3.py"}

\paragraph{=의 사용} 

예를 들어서, 아래의 소스코드에서는 각각 a,b가 bound variable, a가 binding variable, c가 free variable입니다. 
\lstinputlisting[style=python, 
                caption={Types of Variables (variables.py)}]{"../../../src/examples/variables.py"}

\paragraph{함수 인자의 binding} 

함수 인자 역시 함수가 정의된 곳 내에서의 binding을 야기합니다. 예를 들어서 아래 소스코드를 살펴봅시다. 

\lstinputlisting[style=python, 
                caption={Inspecting Function Calls  (example\_interpreter1.py)}]{"../../../src/examples/example_interpreter1.py"}
                
이 때 출력될 값은 321일 것입니다. 이를 이해하기 위해서 파이썬 인터프리터 안에서 어떤 일이 벌어지는지 한 단계씩 살펴보도록 하겠습니다. 

\begin{enumerate} 
\item line 12 : func1('123')을 호출, 반환된 값을 출력함
\item line 1 : func1 정의된 부분으로 감
\item line 2-7 : 이 부분의 식을 계산하되, input\_num을 '123'으로 대체하여 계산함 (=binding이 일어남: input\_num 이 '123'에 bind됨)
\begin{enumerate}
\item line 2-4 : int('123'[0]) == 1 과 같은 계산을 반복 
\item line 7 : func2(1,2,3)을 호출, 반환된 값을 반환함
\end{enumerate}
\item line 9 : func2 정의된 부분으로 감 
\item line 10 : 100c + 10b + a 계산하되, a,b,c를 각각 1,2,3으로 대체하여 계산함 (=binding이 일어남 : a,b,c가 각각 1,2,3에 bind됨)
\end{enumerate}



\end{document}