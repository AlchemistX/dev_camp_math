% !TEX root = textbook.tex
\chapter{실습환경 설정 및 프로그래밍 복습} 

본 단원에서는 실습환경 설정과 파이썬 문법 소개, 그리고 기초적인 프로그래밍의 개념들을 복습하는 데 도움을 주기 위하여 작성되었습니다. 본 단원은 처음으로 프로그래밍을 배우는 사람을 위한 것이 \textbf{아니라} 복습을 위한 것이므로, 처음 프로그래밍을 배우는 분은 다른 교재를 보기를 권장드립니다. 

본 단원에서 예시로 작성된 코드는 src/examples/ 폴더에 들어 있습니다. 

\section{실습환경 설정} 

\subsection{파이썬} 
본 수업에서의 실습은 다른 라이브러리를 필요로 하지 않으므로 파이썬 개발에 필요한 최소한의 환경만 설정해주면 충분합니다. 본 환경설정법은 장고걸스 튜토리얼\footnote{\href{https://tutorial.djangogirls.org/ko/python\_installation/}{장고걸스 튜토리얼 : 파이썬 설치}}의 해당 부분을 참고하여 작성되었습니다. 

\paragraph{Windows} 

먼저, 사용 중인 컴퓨터 윈도우 운영체제가 32비트인지 64비트인지 확인해야 합니다. 확인법은 \href{https://support.microsoft.com/ko-kr/help/13443/windows-which-operating-system}{마이크로소프트 링크} 에서 찾아보실 수 있습니다. 이제 윈도우 용 파이썬 설치파일을 \href{https://www.python.org/downloads/windows/}{파이썬 공식 다운로드 링크}에서 다운로드 할 수 있습니다. 본 교재에서는 파이썬 3 버젼을 사용할 것이므로, Latest Python 3 Release - Python x.x.x 를 찾아서 다운로드받으면 됩니다. 64 비트 버전의 Windows인 경우 Windows x86-64 executable installer를 다운로드하시고, 이외에는 Windows x86 executable installer을 다운로드하면 됩니다. 설치 프로그램을 다운로드 한 후에 실행하고 지시 사항을 따르세요. 

설치하는 동안 "Setup(설치하기)"이라고 표시된 창이 나타납니다. 다음과 같이 "Add Python 3.x to PATH(python3.x를 경로에 추가)"체크 박스를 체크하고 "Install Now(지금 설치하기)"를 클릭하세요.

\paragraph{OS X} 

\href{https://www.python.org/downloads/}{파이썬 공식 사이트}로 가서 파이썬 설치 파일을 다운 받으세요. 

\begin{compactitem}
\item Mac OS X 64-bit/32-bit installer 파일을 다운받습니다.
\item python-3.6.1-macosx10.6.pkg을 더블클릭해 설치합니다.
\end{compactitem}

\paragraph{Linux} 

이미 파이썬 3이 설치되어 있을 것입니다. 

\subsection{IDE}

IDE나 코드 에디터는 개인 취향에 따라서 아래의 옵션 중 골라서 설치하시면 됩니다. 

\begin{compactitem} 
\item PyCharm : 가장 범용적으로 쓰이는 파이썬 IDE입니다. 
\item Spyder 
\item Notepad++ 
\item Atom 
\item Sublime Text 
\item Eclipse : PyDev 플러그인 사용 
\item Visual Studio Code : 파이썬 플러그인 사용
\end{compactitem} 

\subsection{Git}

Git은 버젼 관리 도구로써, 본 수업에서 필수적으로 사용되는 것은 아니지만 사용하는 것에 익숙해지면 쓰일 곳이 많습니다. 특히, 개발자에게 자신이 작성한 코드를 관리하는 것에 이만한 툴이 없습니다. 여기서는 따로 Git의 사용법을 다루지는 않습니다. 본 단락 역시 장고걸스 튜토리얼의 해당 부분\footnote{\href{https://tutorial.djangogirls.org/ko/deploy/}{장고걸스 튜토리얼 : 배포}}을 참고하였습니다. 

\paragraph{Windows, OS X} 

git-scm를 \href{git-scm.com}{링크}에서 다운로드하면 됩니다. 

\paragraph{Linux} 

sudo apt-get install git 으로 git을 다운로드할 수 있습니다. 

\section{파이썬 소개} 


\lstinputlisting[style=python, 
                caption={Hello World! (hello.py)}]{"../../src/examples/hello.py"}


본 단락에서는 파이썬 언어에 대해서 간단히 짚고 넘어갑니다. 

\subsection{파이썬 데이터 타입} 

\subsubsection{Built-in Data Types} 
파이썬은 기본적으로 다음의 빌트인 데이터 타입을 지원\footnote{\href{https://en.wikibooks.org/wiki/Python\_Programming/Data\_Types}{참조 링크 1(위키북스)}, \href{https://docs.python.org/3/library/stdtypes.html}{참조 링크 2(공식 문서)}}\footnote{여기 리스트된 데이터형이 전부는 아니지만, 중요한 데이터형들이니 잘 알아두시길 권장합니다.}합니다. 

\begin{compactitem} 
\item Boolean Type : 참/거짓 값을 나타내는 타입입니다. 
\item Numeric Types : 일반적으로 쓰이는 숫자를 나타내는 타입입니다. 
\item Sequential Types : 배열 형태의 타입입니다. 
\item Mapping Types : key-value 순서쌍 형태의 타입입니다. \footnote{프로그래밍 지식이 있으신 분은 파이썬에서의 dict가 해쉬라고 생각하시면 좋습니다.}
\end{compactitem}

아래에서는 각 타입의 종류와 다양한 연산법에 대해서 알아볼 것입니다. 


\paragraph{Boolean Type} 참(True), 거짓(False)값을 나타냅니다. Boolean 값들은 and, or, not 연산이 가능합니다. 연산의 결과는 아래와 같습니다. 

\lstinputlisting[style=python, 
                caption={Boolean Example  (example\_bool1.py)}]{"../../src/examples/example_bool1.py"}


\paragraph{Numeric Types} int, float, complex가 있습니다. 각각 정수, 실수\footnote{차후에 다루겠지만, 정확하게 실수를 나타내는 것은 불가능합니다. 더 정확하게는, 모든 실수를 정확하게 나타내는 것은 불가능합니다. 여기서의 float은 c언어에서의 double과 같다고 보는 것이 정확합니다.}, 그리고 복소수를 나타냅니다. 

\lstinputlisting[style=python, 
                caption={Numeric Types  (example\_numeric1.py)}]{"../../src/examples/example_numeric1.py"}

파이썬은 일반적인 사칙연산을 지원합니다. 아래에서 어떤 식으로 사칙연산이 사용되는지 볼 수 있습니다. 

\lstinputlisting[style=python, 
                caption={Operations for Numeric Types  (example\_numeric2.py)}]{"../../src/examples/example_numeric2.py"}


\paragraph{Sequential Types} 파이썬에서는 list, tuple, range, string 등의 배열 형태의 데이터형을 지원합니다. 여기서는 문자열 데이터형 string에 대해서 따로 다루지는 않으며, 더 자세한 정보는 \href{https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range}{공식 Documentation}을 참고하시면 됩니다. 

\lstinputlisting[style=python, 
                caption={Sequential Types  (example\_sequence1.py)}]{"../../src/examples/example_sequence1.py"}


Sequence 데이터형들은 다음의 연산들을 지원합니다. 
\begin{compactitem} 
\item a in d : 배열(d) 안에 특정 원소(a)가 있는지를 검사합니다. 
\item + : 배열 두 개를 이어서 새로운 배열을 만듭니다. 같은 데이터형이여야 합니다. 
\item d[i] : d의 i번째 원소를 반환합니다. 
\item d[i:j:k] : d의 i번째 원소부터 j번째 원소까지, k번째 원소마다 선택하여 리스트를 만들어 반환합니다. 
\item d.index(elem) : d에서 elem 이 처음으로 나오는 위치를 반환합니다. 
\end{compactitem}
\lstinputlisting[style=python, 
                caption={Operations for Sequential Types  (example\_sequence2.py)}]{"../../src/examples/example_sequence2.py"}


\paragraph{Mapping Types} key-value 쌍을 저장하는 데이터형으로, 파이썬에서는 dict가 있습니다. 

\lstinputlisting[style=python, 
                linerange  = {1-6, 27},
                caption={Mapping Types  (example\_dict1.py, line 7-26 omitted)}]{"../../src/examples/example_dict1.py"}

dict는 다음의 연산을 지원합니다. 
\begin{compactitem} 
\item d[key] : dict에서 key에 해당되는 value를 반환합니다. 
\item d[key] = val : dict에서 key에 해당되는 value를 val로 업데이트합니다. 
\item d.keys() : dict의 key들을 반환합니다. 
\end{compactitem}

\lstinputlisting[style=python, 
                caption={Operations for Mapping Types  (example\_dict2.py)}]{"../../src/examples/example_dict2.py"}


\subsection{파이썬 문법 : loops, conditionals} 

\paragraph{if-elif-else} 다른 모든 언어와 비슷하게, 파이썬에서도 if-else 문을 지원합니다. 아래와 같은 문법으로 사용됩니다. 

\begin{lstlisting}[style=python] 
if cond1:
    # when cond1 is True 
elif cond2:
    # when cond1 is False and cond2 is True
else:
    # when cond1 is False and cond2 is False
\end{lstlisting}

\paragraph{switch} 파이썬에서는 switch문을 지원하지 않습니다. 하지만, 아래와 같이 switch문을 대체하여 사용할 수는 있습니다. 

\lstinputlisting[style=python, 
                caption={Switch using dict (example\_switch1.py)}]{"../../src/examples/example_switch1.py"}



\paragraph{for loop} 파이썬에서의 for loop는 임의의 Sequential Type 변수에 대해서, 그 변수 안의 원소를 한번씩 돌게 됩니다. 예를 들어서 아래 코드를 살펴봅시다. 

\lstinputlisting[style=python, 
                caption={For Loop Example (example\_for1.py)}]{"../../src/examples/example_for1.py"}


\paragraph{while loop} 파이썬에서의 while문은 다른 언어에서의 while문과 크게 다르지 않습니다. 아래의 소스 코드를 살펴보면 알 수 있을 것입니다. 


\lstinputlisting[style=python, 
                caption={While Loop Example (example\_while1.py)}]{"../../src/examples/example_while1.py"}
                
                
\subsection{파이썬 문법 : 함수, 클래스}

\subsubsection{함수}

파이썬에서 함수는 다음과 같이 정의합니다. 


\lstinputlisting[style=python, 
                caption={Function Syntax (example\_function1.py)}]{"../../src/examples/example_function1.py"}
                
위 소스코드에서 각 항목은 아래와 같은 의미를 가집니다. 

\begin{compactitem} 
\item def : 함수 정의 키워드입니다. 
\item function : 함수 이름을 나타냅니다. 
\item args : 함수 인자입니다. 아래와 같은 옵션이 있습니다. 
\begin{compactitem} 
\item arg 
\item arg\_default : 함수 인자의 기본값을 정해줄 때, =을 이용하여 기본값을 지정해줄 수 있습니다. 
\item *arg\_list : 정해지지 않은 수의 인자를 받고자 할 때, *을 하나 붙여서 들어온 인자를 배열로 받을 수 있습니다. 
\item **arg\_dict : 정해지지 않은 수의 이름이 명시된 인자를 받고자 할 때, *를 두개 붙여서 들어온 인자들을 dict 형태로 받을 수 있습니다. 
\end{compactitem} 
\item return None : 함수의 결과값으로 return 뒤의 구문을 반환합니다. 
\end{compactitem}


아래의 코드\footnote{\href{https://stackoverflow.com/a/21338152}{stackoverflow 질문 : Understanding kwargs in Python} 참조}를 보면 조금 더 명백해집니다. 

\lstinputlisting[style=python, 
                caption={Function Argument Options (example\_function2.py)}]{"../../src/examples/example_function2.py"}
                
위 프로그램의 실행 결과는 다음과 같습니다. 

\begin{lstlisting}[style=stdout, caption = {Output for Function Argmument Options}]
Calling f(1, 2, 3, 4, b = 5, c = 6)
Received by f(a, *args, **kwargs) 
=> f(a=1, args=(2, 3, 4), kwargs={'c': 6, 'b': 5}
Calling g(10, 11, 12, *args, d = 13, e = 14, **kwargs)
Received by g(f, g = 0, *args, **kwargs)
=> g(f=10, g=11, args=(12, 2, 3, 4), kwargs={'c': 6, 'b': 5, 'e': 14, 'd': 13})
\end{lstlisting}

\paragraph{람다 함수}

람다 함수란 익명함수를 뜻합니다. 이는 람다함수가 변수명을 가질 수 없음을 의미하는 것이 \textbf{아닙니다.} 예컨대, 아래의 코드에서의 func1, func2는 둘 다 같은 함수(주어진 수에 2를 더하는)이며, func1은 람다식으로 작성되었지만 엄연히 func1이라는 이름을 가지고 있습니다. 

\lstinputlisting[style=python,  
                caption={Lambda Function Example (example\_lambda1.py)}]{"../../src/examples/example_lambda1.py"}

람다식의 문법은 위 소스 코드에서 볼 수 있듯이 다음과 같이 이루어집니다. 

\begin{compactitem} 
\item lambda : 람다함수 키워드. 람다함수 뒤의 구문 중 콜론 전에 있는 구문은 함수의 인자를, 뒤는 반환하는 값을 나타낸다. 
\item x,y,z(func3)/*args(func4) : 람다함수의 인자. 쉼표로 구분되며, 상기된 *args등도 똑같이 사용 가능함을 func4에서 확인할 수 있다. 
\item x+y+z(func3)/sum(args)(func4) : 람다함수의 반환값. 
\end{compactitem}

익명함수가 가지는 이점 중 하나는, 우리가 정수나 문자열을 다루듯이 함수 또한 하나의 변수로 다루고 싶을 때 편리하다는 점입니다. 본 단락에서는 일반화된 정렬 문제에서 어떤 식으로 람다식이 사용가능한지 보여드리고자 합니다. 

어떤 배열을 정렬하는 문제를 생각해 봅시다. 이 때, 어떤 배열의 원소들이 정수라면 정렬 결과에는 이의가 없을 것입니다. 예컨대, 아래의 코드의 마지막 라인에서 AssertionError가 나지 않는다면 충분할 것입니다. \footnote{물론 실전에서는 더 많은 테스트를 하시는 것을 권장드립니다.}


\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort1.py)}]{"../../src/examples/example_lambda_sort1.py"}


하지만 주어진 리스트가 비교하기 어려운 것들로 되어있는 경우 - 예를 들어서, 숫자 3개짜리 튜플로 되어있는 경우 - 에는 어떤 식으로 배열할 수 있을까요? 이를 위해서는 우선 배열의 원소를 서로 비교하기 위한 기준이 필요할 것입니다. 위 코드의 경우 원소간의 비교 기준은 대소관계이며, 8번째 라인(head>=elem)에 이것이 반영되었다고 볼 수 있습니다. 여기서는 이 기준을 세 숫자의 합으로 생각해 봅시다. 그렇다면, 새로운 기준(세 숫자의 합)을 아래와 같이 반영할 수 있을 것입니다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort2.py)}]{"../../src/examples/example_lambda_sort2.py"}


이제 여기서 조금 더 나아가서, 다음과 같은 소스를 생각해 봅시다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort3.py)}]{"../../src/examples/example_lambda_sort3.py"}

여기서, 위 소스를 조금 더 간소화해서 애초에 compare 함수를 def를 쓰지 않고 람다식을 이용하여 저렇게 쓸 수 있습니다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort4.py)}]{"../../src/examples/example_lambda_sort4.py"}
%
%\subsubsection{클래스}
%
%본 단락에서는 파이썬에서 클래스를 어떻게 정의하는지를 살펴보고자 합니다. 
%\lstinputlisting[style=python,  
%                caption={Defining a Class  (example\_class1.py)}]{"../../src/examples/example_class1.py"}
%
%\paragraph{Magic Methods} Magic Method는 
%
%\lstinputlisting[style=python,  
%                caption={Inspecting Function Calls  (example\_class2.py)}]{"../../src/examples/example_class2.py"}
%\paragraph{클래스 상속} 클래스 상속\footnote{\href{https://www.python-course.eu/python3\_inheritance.php}{링크} 참조}
%
%\lstinputlisting[style=python,  
%                caption={Inspecting Function Calls  (example\_class3.py)}]{"../../src/examples/example_class3.py"}
%
\subsection{파이썬 인터프리터의 이해}

본 단락에서는 주어진 소스 코드를 파이썬이 계산하는 법을 알아볼 것\footnote{\href{https://docs.python.org/3/reference/executionmodel.html}{파이썬 공식 Documentation} 참조}입니다. 본격적인 설명에 앞서, 변수의 종류에 대해서 설명하겠습니다. 일반적으로 변수에는 다음의 세 종류가 있습니다. 

\begin{compactitem} 
\item Bound variable : 어떤 값이나 다른 변수에 의해서 값이 결정되는지 정해진 변수
\item Binding variable : Bound variable의 값을 결정하는 변수 
\item Free variable : Bound되지 않은 변수 
\end{compactitem}

이 때, 파이썬 인터프리터\footnote{사실 많은 인터프리터가 대부분 이렇게 동작합니다.}는 \textbf{bound variable을 binding variable로 대체(substitute) 하여} 계산합니다. 만약 계산해야 하는 모든 변수들의 값이 결국 어떤 값(숫자, 문자열 등등)으로 환원되면 그 값을 계산하여 반환하고, 그렇지 않다면 에러를 반환합니다. 따라서 파이썬 인터프리터의 동작을 이해하는 것은 곧 어떤 식으로 변수들이 서로를 bind/bound 하는지를 이해하고, 이를 기반으로 \textbf{기계적으로} 변수를 적절한 값으로 대체하여 계산을 수행함을 의미합니다. 

Binding이 일어나는 경우는 아래와 같습니다. 

\paragraph{import문의 사용} import문을 사용할 경우, import된 모듈에서의 모든 namespace가 bind됩니다. 

\paragraph{for loop} for loop에서 헤더는 루프 코드블럭 안에서 for loop 헤더에서 선언된 변수를 bind 합니다. 

\paragraph{함수, 클래스의 정의} 함수나 클래스의 정의는 함수나 클래스 이름을 bind하게 됩니다. 예를 들어서 아래 소스코드를 보면, compare이라는 변수는 1번 라인에 의해서 2번 라인에 binding되어, 14번 라인을 거쳐 11번 라인에서 쓰이게 됩니다. 


\lstinputlisting[style=python,  
                caption={Binding in Function definition  (example\_lambda\_sort3.py)}]{"../../src/examples/example_lambda_sort3.py"}

\paragraph{=의 사용} 

예를 들어서, 아래의 소스코드에서는 각각 a,b가 bound variable, a가 binding variable, c가 free variable입니다. 
\lstinputlisting[style=python, 
                caption={Types of Variables (variables.py)}]{"../../src/examples/variables.py"}

\paragraph{함수 인자의 binding} 

함수 인자 역시 함수가 정의된 곳 내에서의 binding을 야기합니다. 예를 들어서 아래 소스코드를 살펴봅시다. 

\lstinputlisting[style=python, 
                caption={Inspecting Function Calls  (example\_interpreter1.py)}]{"../../src/examples/example_interpreter1.py"}
                
이 때 출력될 값은 321일 것입니다. 이를 이해하기 위해서 파이썬 인터프리터 안에서 어떤 일이 벌어지는지 한 단계씩 살펴보도록 하겠습니다. 

\begin{enumerate} 
\item line 12 : func1('123')을 호출, 반환된 값을 출력함
\item line 1 : func1 정의된 부분으로 감
\item line 2-7 : 이 부분의 식을 계산하되, input\_num을 '123'으로 대체하여 계산함 (=binding이 일어남: input\_num 이 '123'에 bind됨)
\begin{enumerate}
\item line 2-4 : int('123'[0]) == 1 과 같은 계산을 반복 
\item line 7 : func2(1,2,3)을 호출, 반환된 값을 반환함
\end{enumerate}
\item line 9 : func2 정의된 부분으로 감 
\item line 10 : 100c + 10b + a 계산하되, a,b,c를 각각 1,2,3으로 대체하여 계산함 (=binding이 일어남 : a,b,c가 각각 1,2,3에 bind됨)
\end{enumerate}










                
                
% \section{프로그래밍 복습} 

% \subsection{시간복잡도}

% \paragraph{Big-O 표기법}

% \paragraph{계산 예시}

% \subsection{데이터구조와 추상 데이터 타입(Abstract Data Type, ADT)} 

% \paragraph{데이터구조 vs ADT}

% \subsubsection{추상 데이터 타입}
% \paragraph{스택 ADT}
% \paragraph{큐 ADT}
% \paragraph{트리 ADT} 
% \paragraph{그래프 ADT}


% \subsubsection{데이터구조} 

% \paragraph{링크드리스트 데이터구조}
% \paragraph{이진트리 데이터구조} 

% \subsection{알고리즘} 

% \subsubsection{재귀}

% \paragraph{예시 : 하노이의 탑} 

% \lstinputlisting[style=python,  
                % caption={Inspecting Function Calls  (example\_.py)}]{"../../src/examples/example_.py"}


% \subsubsection{동적 프로그래밍} 


% \paragraph{예시 : Longest Common Subsequence(LCS)} 

% \lstinputlisting[style=python,  
                % caption={Inspecting Function Calls  (example\_.py)}]{"../../src/examples/example_.py"}





